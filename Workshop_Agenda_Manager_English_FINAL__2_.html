<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Workshop Agenda Manager - Enhanced DOCX Logo Export</title>
    <script src="https://cdn.jsdelivr.net/npm/docx@7.8.2/build/index.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Calibri', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .header {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 20px;
        }

        .logo {
            font-size: 2rem;
            font-weight: bold;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
            border: 1px solid rgba(102, 126, 234, 0.1);
            transition: all 0.3s ease;
        }

        .section:hover {
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.12);
            transform: translateY(-2px);
        }

        .section h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.4rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section h2::before {
            content: "üìã";
            font-size: 1.2rem;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .section-header h2 {
            margin-bottom: 0;
            flex: 1;
        }

        .section-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            font-weight: bold;
            color: #555;
            font-size: 0.9rem;
        }

        input, textarea, select {
            padding: 12px 15px;
            border: 2px solid #e1e5e9;
            border-radius: 10px;
            font-size: 14px;
            font-family: 'Calibri', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            transition: all 0.3s ease;
            background: #fafbfc;
        }

        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: #667eea;
            background: white;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            transform: translateY(-1px);
        }

        .dynamic-list {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-top: 10px;
        }

        .list-item {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }

        .list-item input {
            flex: 1;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            text-decoration: none;
            font-size: 14px;
        }

        .btn-sm {
            padding: 6px 10px;
            font-size: 0.8rem;
            gap: 4px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
            transform: translateY(-2px);
        }

        .btn-danger {
            background: #dc3545;
            color: white;
            padding: 6px 10px;
            font-size: 12px;
            min-width: auto;
        }

        .btn-danger:hover {
            background: #c82333;
            transform: translateY(-2px);
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
            transform: translateY(-2px);
        }

        .btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .btn-warning:hover {
            background: #e0a800;
            transform: translateY(-2px);
        }

        .day-container {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            border-left: 4px solid #667eea;
        }

        .day-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .day-header h3 {
            color: #333;
            font-size: 1.2rem;
            font-weight: bold;
        }

        .agenda-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            background: white;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .agenda-table th {
            background: #667eea;
            color: white;
            padding: 15px;
            text-align: center;
            font-weight: 600;
            border-right: 1px solid rgba(255, 255, 255, 0.2);
        }

        .agenda-table th:last-child {
            border-right: none;
        }

        .agenda-table td {
            padding: 15px;
            text-align: center;
            border-bottom: 1px solid #e9ecef;
            border-right: 1px solid #e9ecef;
            vertical-align: middle;
        }

        .agenda-table td:last-child {
            border-right: none;
        }

        .agenda-table tr:last-child td {
            border-bottom: none;
        }

        .agenda-table tr.break-row {
            background-color: #f8f9fa;
        }

        .session-number-cell {
            font-weight: bold;
            color: #667eea;
            min-width: 120px;
            width: 15%;
        }

        .session-number-cell input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            text-align: center;
            font-weight: bold;
            color: #667eea;
            background: #f8f9fa;
            font-family: 'Calibri', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 14px;
        }

        .session-number-cell input:focus {
            outline: none;
            border-color: #667eea;
            background: white;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
        }

        .time-input-cell {
            min-width: 140px;
            width: 14%;
        }

        .time-input-cell input {
            width: 120px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            text-align: center;
            font-family: 'Calibri', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .duration-cell {
            min-width: 80px;
            width: 10%;
        }

        .duration-input {
            width: 60px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            text-align: center;
            font-weight: 600;
            font-family: 'Calibri', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #fafbfc;
            cursor: pointer;
        }

        .duration-input:focus {
            outline: none;
            border-color: #667eea;
            background: white;
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.1);
        }

        .activity-cell {
            min-width: 300px;
            width: 35%;
        }

        .activity-cell textarea {
            width: 100%;
            min-height: 60px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            resize: vertical;
            font-family: 'Calibri', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .facilitator-cell {
            min-width: 120px;
            width: 20%;
        }

        .facilitator-cell textarea {
            width: 100%;
            min-height: 60px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            resize: vertical;
            font-family: 'Calibri', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .actions-cell {
            min-width: 60px;
            width: 8%;
        }

        .actions {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid #e9ecef;
        }

        .hidden {
            display: none;
        }

        /* Auto-update animation */
        @keyframes updatePulse {
            0% { background-color: #fff3cd; }
            50% { background-color: #ffeaa7; }
            100% { background-color: #fff3cd; }
        }

        .auto-updating {
            animation: updatePulse 1.5s ease-in-out;
        }

        /* Auto-calculated field styles */
        @keyframes autoCalculated {
            0% { background-color: #e8f5e8; box-shadow: 0 0 0 2px rgba(40, 167, 69, 0.2); }
            50% { background-color: #d4edda; box-shadow: 0 0 0 3px rgba(40, 167, 69, 0.3); }
            100% { background-color: #ffffff; box-shadow: none; }
        }

        .auto-calculated-end {
            animation: autoCalculated 1.5s ease-in-out;
        }

        @keyframes autoCalculatedStart {
            0% { background-color: #fff3cd; box-shadow: 0 0 0 2px rgba(255, 193, 7, 0.2); }
            50% { background-color: #ffeaa7; box-shadow: 0 0 0 3px rgba(255, 193, 7, 0.3); }
            100% { background-color: #ffffff; box-shadow: none; }
        }

        .auto-calculated-start {
            animation: autoCalculatedStart 1.5s ease-in-out;
        }

        /* Chain reaction notification */
        .chain-reaction-active {
            position: relative;
        }

        .chain-reaction-active::after {
            content: "‚ö°";
            position: absolute;
            right: -20px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 16px;
            animation: chainPulse 1s ease-in-out infinite;
        }

        @keyframes chainPulse {
            0%, 100% { opacity: 0.5; transform: translateY(-50%) scale(1); }
            50% { opacity: 1; transform: translateY(-50%) scale(1.2); }
        }

        /* Participant Notes */
        .notes-section textarea {
            min-height: 200px;
            resize: vertical;
            width: 100%;
            font-size: 11pt;
        }

        /* File input styling */
        .file-input {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .file-input label {
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 20px;
            background: #17a2b8;
            color: white;
            border-radius: 8px;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        .file-input label:hover {
            background: #138496;
            transform: translateY(-2px);
        }

        /* LinkedIn Post Modal */
        .linkedin-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .linkedin-modal-content {
            background: white;
            border-radius: 12px;
            padding: 25px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .linkedin-modal h3 {
            color: #0077b5;
            margin-bottom: 15px;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .linkedin-post-content {
            background: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            font-family: 'Calibri', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.5;
            white-space: pre-line;
            min-height: 200px;
        }

        .linkedin-modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            flex-wrap: wrap;
        }

        .linkedin-modal-actions .btn {
            min-width: 120px;
        }

        /* Footer Styles */
        .footer {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid #e9ecef;
            text-align: center;
        }

        .version {
            font-size: 0.8rem;
            font-weight: regular;
            color: #667eea;
            margin-bottom: 12px;
            text-align: center;
        }

        .disclaimer {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px 20px;
            margin: 0 auto;
            max-width: 800px;
            border-left: 3px solid #ffc107;
            text-align: center;
            font-size: 0.85rem;
            line-height: 1.4;
            color: #666;
        }

        .disclaimer p {
            margin: 0;
        }

        .disclaimer strong {
            color: #333;
            font-weight: bold;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .container {
                padding: 20px;
                margin: 10px;
            }

            .header {
                flex-direction: column;
                text-align: center;
            }

            .form-row {
                grid-template-columns: 1fr;
            }

            .actions {
                flex-direction: column;
                align-items: stretch;
            }

            .btn {
                justify-content: center;
            }

            .section-header {
                flex-direction: column;
                align-items: stretch;
                gap: 15px;
            }

            .section-header h2 {
                text-align: center;
            }

            .section-buttons {
                justify-content: center;
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 10px;
            }

            .container {
                padding: 15px;
            }

            .section {
                padding: 20px;
            }

            .logo {
                font-size: 1.5rem;
            }
        }

        /* Animation */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .fade-in {
            animation: fadeIn 0.5s ease-out;
        }

        /* User Guide Styles */
        .user-guide-section {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 12px;
            margin-bottom: 25px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(102, 126, 234, 0.2);
            overflow: hidden;
        }

        .user-guide-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
            font-weight: 600;
            font-size: 1.1rem;
        }

        .user-guide-header:hover {
            background: linear-gradient(135deg, #5a6fd8 0%, #6a4190 100%);
            transform: translateY(-1px);
        }

        .guide-title {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .guide-toggle {
            font-size: 1.2rem;
            transition: transform 0.3s ease;
            font-weight: bold;
        }

        .guide-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .user-guide-content {
            padding: 15px 20px;
            display: block;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .user-guide-content.hidden {
            display: none;
        }

        .guide-section {
            margin-bottom: 15px;
        }

        .guide-section h4 {
            color: #333;
            margin: 0 0 8px 0;
            font-size: 1rem;
            font-weight: bold;
        }

        .guide-section ol {
            margin: 0;
            padding-left: 20px;
        }

        .guide-section ol li {
            margin-bottom: 6px;
            line-height: 1.3;
        }

        .sub-list {
            margin: 6px 0 0 0;
            padding-left: 20px;
            list-style-type: disc;
        }

        .sub-list li {
            margin-bottom: 4px;
            font-size: 0.85rem;
        }

        .guide-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 10px;
        }

        .guide-column h4 {
            color: #333;
            margin: 0 0 8px 0;
            font-size: 1rem;
            font-weight: bold;
        }

        .guide-column ul {
            margin: 0;
            padding-left: 16px;
            list-style-type: disc;
        }

        .guide-column ul li {
            margin-bottom: 4px;
            line-height: 1.3;
            font-size: 0.85rem;
        }

        .guide-column strong {
            color: #667eea;
            font-weight: 600;
        }

        /* Mobile Responsive for User Guide */
        @media (max-width: 768px) {
            .user-guide-header {
                padding: 10px 15px;
                font-size: 1rem;
            }

            .user-guide-content {
                padding: 12px 15px;
                font-size: 0.85rem;
            }

            .guide-columns {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .guide-section h4,
            .guide-column h4 {
                font-size: 0.95rem;
            }

            .sub-list li,
            .guide-column ul li {
                font-size: 0.8rem;
            }
        }

        @media (max-width: 480px) {
            .user-guide-header {
                padding: 8px 12px;
                font-size: 0.9rem;
            }

            .user-guide-content {
                padding: 10px 12px;
                font-size: 0.8rem;
            }

            .guide-section ol,
            .guide-column ul,
            .sub-list {
                padding-left: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="logo">Workshop Agenda Manager</div>
        </div>

        <!-- User Guide -->
        <div class="user-guide-section">
            <div class="user-guide-header" onclick="toggleUserGuide()">
                <span class="guide-title">
                    <span>üìö</span>
                    <span>Quick User Guide</span>
                </span>
                <span class="guide-toggle" id="guideToggle">‚ñº</span>
            </div>
            <div class="user-guide-content" id="userGuideContent">
                <div class="guide-section">
                    <h4>üìã Basic Workflow:</h4>
                    <ol>
                        <li><strong>Workshop Details</strong>: Fill in title, dates, location, and choose type (face-to-face or online)</li>
                        <li><strong>Online Platform</strong>: Add platform name (Zoom, Google Meet, Microsoft Teams) for online workshops</li>
                        <li><strong>Registration Link</strong>: Add registration URL for online workshops (auto-included in LinkedIn posts)</li>
                        <li><strong>Contact Information</strong>: Add facilitator name, phone, and email (optional)</li>
                        <li><strong>Objectives & Outcomes</strong>: Add your learning goals</li>
                        <li><strong>Create Days</strong>: Add workshop days and sessions</li>
                        <li>
                            <strong>Enhanced Smart Time Calculator - How It Works</strong>:
                            <ul class="sub-list">
                                <li><strong>Change 'From' Time</strong>: Modify start time ‚Üí End time calculated automatically + all following sessions updated</li>
                                <li><strong>Change 'To' Time</strong>: Modify end time ‚Üí Duration calculated automatically + all following sessions updated</li>
                                <li><strong>Change Duration</strong>: Modify duration ‚Üí End time calculated automatically + all following sessions updated</li>
                                <li><strong>Smart Cascade Calculation</strong>: Enter first session start time + durations for sessions ‚Üí Complete schedule built automatically!</li>
                                <li><strong>Instant Chain Reaction</strong>: Any change in any session affects all subsequent sessions automatically!</li>
                                <li><strong>Complete Flexibility</strong>: Edit any time field and the system adapts automatically</li>
                            </ul>
                        </li>
                        <li><strong>Export & Share</strong>: Save as Word document, JSON file, or generate LinkedIn posts</li>
                    </ol>
                </div>

                <div class="guide-columns">
                    <div class="guide-column">
                        <h4>üí° Pro Tips:</h4>
                        <ul>
                            <li><strong>Location Details</strong>: Location (city-building), Address (street), Venue (specific hall/room)</li>
                            <li><strong>Online Platform</strong>: Specify platform name clearly (Zoom, Google Meet, Teams) for easy access</li>
                            <li><strong>Contact Info</strong>: Add facilitator details for professional communication</li>
                            <li><strong>Start with Day 1</strong>: Set your first session start time, then just use durations</li>
                        </ul>
                    </div>

                    <div class="guide-column">
                        <h4>üéØ Quick Actions:</h4>
                        <ul>
                            <li><strong>+ Add Session</strong>: Regular workshop session</li>
                            <li><strong>üì§ Share</strong>: Email, WhatsApp, or LinkedIn post generator</li>
                            <li><strong>üíº LinkedIn</strong>: Auto-generate professional posts for promotion</li>
                            <li><strong>üìÑ Export Word</strong>: Download formatted document</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- Workshop Details -->
        <div class="section">
            <div class="section-header">
                <h2>Workshop Details</h2>
                <div class="section-buttons">
                    <button type="button" class="btn btn-secondary" onclick="clearWorkshopDetails()">
                        <span>üóëÔ∏è</span>
                        <span>Clear Details</span>
                    </button>
                </div>
            </div>
            <div class="form-row">
                <div class="form-group">
                    <label>Workshop Title</label>
                    <input type="text" id="workshopTitle" placeholder="Enter workshop title">
                </div>
                <div class="form-group">
                    <label>Date From</label>
                    <input type="date" id="workshopDateFrom" onchange="updateAllDayHeaders()">
                </div>
                <div class="form-group">
                    <label>Date To</label>
                    <input type="date" id="workshopDateTo" onchange="updateAllDayHeaders()">
                </div>
            </div>
            
            <div class="form-row">
                <div class="form-group">
                    <label>Location</label>
                    <input type="text" id="workshopLocation" placeholder="e.g., Iraq-Baghdad-Training Center">
                </div>
                <div class="form-group">
                    <label>Full Address</label>
                    <textarea id="workshopAddress" rows="2" placeholder="Street address, postal code, city details (optional)"></textarea>
                </div>
                <div class="form-group">
                    <label>Venue Details</label>
                    <input type="text" id="workshopVenue" placeholder="e.g., Conference Hall A, Room 205, 2nd Floor">
                </div>
            </div>
            
            <!-- Workshop Type and Registration -->
            <div class="form-row">
                <div class="form-group">
                    <label>Workshop Type</label>
                    <div style="display: flex; gap: 20px; margin-top: 8px;">
                        <label style="display: flex; align-items: center; gap: 8px; font-weight: normal; cursor: pointer;">
                            <input type="radio" name="workshopType" value="face-to-face" id="typeFaceToFace" checked onchange="toggleOnlineFields()">
                            <span>Face to Face</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; font-weight: normal; cursor: pointer;">
                            <input type="radio" name="workshopType" value="online" id="typeOnline" onchange="toggleOnlineFields()">
                            <span>Online</span>
                        </label>
                    </div>
                </div>
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <span>Platform Name</span>
                        <small style="color: #666; font-size: 0.75rem; font-weight: normal;">
                            (For online workshops)
                        </small>
                    </label>
                    <input type="text" id="platformName" placeholder="e.g., Zoom, Google Meet, Microsoft Teams" style="opacity: 0.5;" disabled>
                </div>
                <div class="form-group">
                    <label style="display: flex; align-items: center; gap: 10px;">
                        <span>Registration Link</span>
                        <small style="color: #666; font-size: 0.75rem; font-weight: normal;">
                            (For online workshops)
                        </small>
                    </label>
                    <input type="url" id="registrationLink" placeholder="Enter registration URL (optional)" style="opacity: 0.5;" disabled>
                </div>
            </div>
            
            <!-- Contact Information Section -->
            <h3 style="color: #333; margin: 20px 0 15px 0; font-size: 1.2rem; font-weight: bold; border-bottom: 2px solid #e9ecef; padding-bottom: 8px;">
                üìû Contact Information
            </h3>
            <div class="form-row">
                <div class="form-group">
                    <label>Facilitator Name</label>
                    <input type="text" id="facilitatorName" placeholder="Enter main facilitator name (optional)">
                </div>
                <div class="form-group">
                    <label>Phone Number</label>
                    <input type="tel" id="facilitatorPhone" placeholder="Enter contact phone (optional)">
                </div>
                <div class="form-group">
                    <label>Email Address</label>
                    <input type="email" id="facilitatorEmail" placeholder="Enter contact email (optional)">
                </div>
            </div>
        </div>

        <!-- Objectives -->
        <div class="section">
            <div class="section-header">
                <h2>Objectives</h2>
                <div class="section-buttons">
                    <button type="button" class="btn btn-primary" onclick="addObjective()">
                        <span>+ Add Objective</span>
                    </button>
                    <button type="button" class="btn btn-secondary" onclick="clearObjectives()">
                        <span>üóëÔ∏è</span>
                        <span>Clear All</span>
                    </button>
                </div>
            </div>
            <div class="dynamic-list" id="objectivesList">
                <div class="list-item">
                    <input type="text" placeholder="Enter objective">
                    <button type="button" class="btn btn-danger" onclick="removeItem(this)">‚úï</button>
                </div>
            </div>
        </div>

        <!-- Expected Outcomes -->
        <div class="section">
            <div class="section-header">
                <h2>Expected Outcomes</h2>
                <div class="section-buttons">
                    <button type="button" class="btn btn-primary" onclick="addOutcome()">
                        <span>+ Add Outcome</span>
                    </button>
                    <button type="button" class="btn btn-secondary" onclick="clearOutcomes()">
                        <span>üóëÔ∏è</span>
                        <span>Clear All</span>
                    </button>
                </div>
            </div>
            <div class="dynamic-list" id="outcomesList">
                <div class="list-item">
                    <input type="text" placeholder="Enter expected outcome">
                    <button type="button" class="btn btn-danger" onclick="removeItem(this)">‚úï</button>
                </div>
            </div>
        </div>

        <!-- Agenda Days -->
        <div class="section">
            <h2>Agenda Days</h2>
            <div class="duration-tip" style="background: #e3f2fd; border-left: 4px solid #2196f3; padding: 12px 15px; margin-bottom: 20px; border-radius: 8px; font-size: 0.9rem; color: #1565c0;">
                <strong>üöÄ Enhanced Smart Time Calculator:</strong> 
                (1) Change any 'From' time ‚Üí 'To' time calculated automatically + all following sessions updated. (2) Change any 'To' time ‚Üí Duration calculated automatically + all following sessions updated. (3) Change any Duration ‚Üí 'To' time calculated automatically + all following sessions updated. (4) <strong>Smart Cascade Calculation:</strong> Enter first start time + at least two durations ‚Üí Complete schedule auto-generated! (5) Instant Chain Reaction: Any change in any session automatically updates all subsequent sessions!
            </div>
            <div id="daysContainer">
                <!-- Days will be dynamically added here -->
            </div>
            <button type="button" class="btn btn-primary" onclick="addDay()">
                <span>+ Add Day</span>
            </button>
        </div>

        <!-- Participant Notes -->
        <div class="section notes-section">
            <div class="section-header">
                <h2>Participant Notes</h2>
                <div class="section-buttons">
                    <button type="button" class="btn btn-secondary" onclick="addNumberingToNotes()" title="Add numbering to lines">
                        <span>üî¢</span>
                        <span>Numbering</span>
                    </button>
                    <button type="button" class="btn btn-secondary" onclick="addBulletsToNotes()" title="Add bullets to lines">
                        <span>‚Ä¢</span>
                        <span>Bullets</span>
                    </button>
                    <button type="button" class="btn btn-secondary" onclick="clearParticipantNotes()">
                        <span>üóëÔ∏è</span>
                        <span>Clear Notes</span>
                    </button>
                </div>
            </div>
            <textarea id="participantNotes" placeholder="Enter notes and instructions for participants..."></textarea>
        </div>

        <!-- Actions -->
        <div class="actions">
            <button type="button" class="btn btn-success" onclick="saveData()">
                <span>üíæ</span>
                <span>Save Data</span>
            </button>
            <button type="button" class="btn btn-primary" onclick="exportJSON()">
                <span>üìÑ</span>
                <span>Export JSON</span>
            </button>
            <button type="button" class="btn btn-primary" onclick="exportWord()">
                <span>üìù</span>
                <span>Export Word</span>
            </button>
            <div class="file-input">
                <input type="file" id="fileInput" accept=".json" onchange="loadData(event)">
                <label for="fileInput">
                    <span>üìÇ</span>
                    <span>Load File</span>
                </label>
            </div>
            <button type="button" class="btn btn-primary" onclick="generateLinkedInPost()" id="shareBtn">
                <span>üíº</span>
                <span>LinkedIn Post</span>
            </button>
        </div>

        <!-- Footer -->
        <div class="footer">
            <div class="version">¬© 2025 Workshop Agenda Manager - by Husham Jawad. Version 3.0. All rights reserved</div>
            <div class="disclaimer">
                <p>
                    <strong>Disclaimer:</strong> This free tool helps manage workshop agendas. Use at your own risk - no warranties or liability assumed. Always backup your data.
                </p>
            </div>
        </div>
    </div>

    <script>
        let workshopData = {
            title: '',
            dateFrom: '',
            dateTo: '',
            location: '',
            objectives: [],
            outcomes: [],
            days: [],
            notes: ''
        };
        let dayCounter = 0;

        // Date and day name arrays
        const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 
                           'July', 'August', 'September', 'October', 'November', 'December'];

        // Format date with day name
        function formatDayDate(dayIndex) {
            const startDateInput = document.getElementById('workshopDateFrom');
            if (!startDateInput.value) {
                return `Day ${dayIndex + 1}`;
            }

            const startDate = new Date(startDateInput.value);
            const currentDate = new Date(startDate);
            currentDate.setDate(startDate.getDate() + dayIndex);

            const dayName = dayNames[currentDate.getDay()];
            const day = currentDate.getDate();
            const month = monthNames[currentDate.getMonth()];
            const year = currentDate.getFullYear();

            return `Day ${dayIndex + 1}: ${dayName}, ${day} ${month} ${year}`;
        }

        // Update all day headers with correct dates
        function updateAllDayHeaders() {
            try {
                const dayHeaders = document.querySelectorAll('.day-header h3');
                if (dayHeaders) {
                    dayHeaders.forEach((h3, index) => {
                        if (h3) {
                            h3.textContent = formatDayDate(index);
                        }
                    });
                }
            } catch (error) {
                console.error('Error updating day headers:', error);
            }
        }

        // Notification system
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 12px 20px;
                border-radius: 8px;
                color: white;
                font-weight: bold;
                z-index: 9999;
                max-width: 300px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                transition: all 0.3s ease;
            `;
            
            switch(type) {
                case 'success':
                    notification.style.background = '#28a745';
                    break;
                case 'error':
                    notification.style.background = '#dc3545';
                    break;
                case 'warning':
                    notification.style.background = '#ffc107';
                    notification.style.color = '#212529';
                    break;
                default:
                    notification.style.background = '#17a2b8';
            }
            
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
        }

        // Toggle online fields based on workshop type
        function toggleOnlineFields() {
            const isOnline = document.getElementById('typeOnline').checked;
            const registrationLink = document.getElementById('registrationLink');
            const platformName = document.getElementById('platformName');
            
            if (isOnline) {
                registrationLink.disabled = false;
                registrationLink.style.opacity = '1';
                platformName.disabled = false;
                platformName.style.opacity = '1';
                platformName.focus();
            } else {
                registrationLink.disabled = true;
                registrationLink.style.opacity = '0.5';
                registrationLink.value = '';
                platformName.disabled = true;
                platformName.style.opacity = '0.5';
                platformName.value = '';
            }
        }

        function toggleUserGuide() {
            const content = document.getElementById('userGuideContent');
            const toggle = document.getElementById('guideToggle');
            
            if (content.classList.contains('hidden')) {
                content.classList.remove('hidden');
                toggle.classList.remove('collapsed');
                toggle.textContent = '‚ñº';
            } else {
                content.classList.add('hidden');
                toggle.classList.add('collapsed');
                toggle.textContent = '‚ñ∂';
            }
        }

        // Add objective
        function addObjective() {
            const container = document.getElementById('objectivesList');
            const item = document.createElement('div');
            item.className = 'list-item fade-in';
            item.innerHTML = `
                <input type="text" placeholder="Enter objective">
                <button type="button" class="btn btn-danger" onclick="removeItem(this)">‚úï</button>
            `;
            container.appendChild(item);
        }

        // Add outcome
        function addOutcome() {
            const container = document.getElementById('outcomesList');
            const item = document.createElement('div');
            item.className = 'list-item fade-in';
            item.innerHTML = `
                <input type="text" placeholder="Enter expected outcome">
                <button type="button" class="btn btn-danger" onclick="removeItem(this)">‚úï</button>
            `;
            container.appendChild(item);
        }

        // Remove item
        function removeItem(button) {
            button.parentElement.remove();
        }

        // Clear workshop details
        function clearWorkshopDetails() {
            if (confirm('Are you sure you want to clear all workshop details?')) {
                document.getElementById('workshopTitle').value = '';
                document.getElementById('workshopDateFrom').value = '';
                document.getElementById('workshopDateTo').value = '';
                document.getElementById('workshopLocation').value = '';
                document.getElementById('workshopAddress').value = '';
                document.getElementById('workshopVenue').value = '';
                document.getElementById('registrationLink').value = '';
                document.getElementById('platformName').value = '';
                document.getElementById('typeFaceToFace').checked = true;
                document.getElementById('typeOnline').checked = false;
                toggleOnlineFields();
                document.getElementById('facilitatorName').value = '';
                document.getElementById('facilitatorPhone').value = '';
                document.getElementById('facilitatorEmail').value = '';
            }
        }

        // Clear all objectives
        function clearObjectives() {
            if (confirm('Are you sure you want to clear all objectives?')) {
                const container = document.getElementById('objectivesList');
                container.innerHTML = '<div class="list-item"><input type="text" placeholder="Enter objective"><button type="button" class="btn btn-danger" onclick="removeItem(this)">‚úï</button></div>';
            }
        }

        // Clear all outcomes
        function clearOutcomes() {
            if (confirm('Are you sure you want to clear all expected outcomes?')) {
                const container = document.getElementById('outcomesList');
                container.innerHTML = '<div class="list-item"><input type="text" placeholder="Enter expected outcome"><button type="button" class="btn btn-danger" onclick="removeItem(this)">‚úï</button></div>';
            }
        }

        // Clear participant notes
        function clearParticipantNotes() {
            if (confirm('Are you sure you want to clear all participant notes?')) {
                document.getElementById('participantNotes').value = '';
                showNotification('Notes cleared successfully!', 'success');
            }
        }

        // Add numbering to participant notes
        function addNumberingToNotes() {
            const textarea = document.getElementById('participantNotes');
            const text = textarea.value;
            
            if (!text.trim()) {
                showNotification('No text to number!', 'warning');
                return;
            }
            
            const lines = text.split('\n');
            const numberedLines = lines.map((line, index) => {
                const trimmedLine = line.trim();
                if (!trimmedLine) return '';
                
                // Remove existing numbering or bullets
                const cleanLine = trimmedLine.replace(/^[\d‚Ä¢\-\*]+[\.\)]\s*/, '');
                return `${index + 1}. ${cleanLine}`;
            });
            
            textarea.value = numberedLines.join('\n');
            showNotification('Numbering added!', 'success');
        }

        // Add bullets to participant notes
        function addBulletsToNotes() {
            const textarea = document.getElementById('participantNotes');
            const text = textarea.value;
            
            if (!text.trim()) {
                showNotification('No text to add bullets!', 'warning');
                return;
            }
            
            const lines = text.split('\n');
            const bulletedLines = lines.map(line => {
                const trimmedLine = line.trim();
                if (!trimmedLine) return '';
                
                // Remove existing numbering or bullets
                const cleanLine = trimmedLine.replace(/^[\d‚Ä¢\-\*]+[\.\)]\s*/, '');
                return `‚Ä¢ ${cleanLine}`;
            });
            
            textarea.value = bulletedLines.join('\n');
            showNotification('Bullets added!', 'success');
        }

        // Add day
        function addDay() {
            const container = document.getElementById('daysContainer');
            const dayDiv = document.createElement('div');
            dayDiv.className = 'day-container fade-in';
            
            const dayHeaderText = formatDayDate(dayCounter);
            
            dayDiv.innerHTML = `
                <div class="day-header">
                    <h3>${dayHeaderText}</h3>
                    <button type="button" class="btn btn-danger" onclick="removeDay(this)">
                        <span>Remove Day</span>
                    </button>
                </div>
                <table class="agenda-table">
                    <thead>
                        <tr>
                            <th>Session Number</th>
                            <th>From</th>
                            <th>To</th>
                            <th>Duration (min)*</th>
                            <th>Activities</th>
                            <th>Facilitator(s)</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody class="sessions-container">
                        <!-- Sessions will be added here -->
                    </tbody>
                </table>
                <div style="margin-top: 15px; display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                    <button type="button" class="btn btn-secondary" onclick="addSession(this)">
                        <span>+ Add Session</span>
                    </button>
                    <button type="button" class="btn btn-secondary" onclick="addBreak(this)">
                        <span>+ Add Break</span>
                    </button>
                    <button type="button" class="btn btn-danger" onclick="clearDayDetails(this)" style="background: #dc3545;" title="Clear all sessions and breaks">
                        <span>üóëÔ∏è</span>
                        <span>Clear Details</span>
                    </button>
                </div>
            `;
            container.appendChild(dayDiv);
            
            dayCounter++;
            
            // Auto-copy session times from Day 1 if this is Day 2 or later
            if (dayCounter > 1) {
                copySessionTimesFromDay1(dayDiv);
            }
        }

        // Copy session times from Day 1 to new days
        function copySessionTimesFromDay1(newDayDiv) {
            try {
                const firstDay = document.querySelector('.day-container');
                if (!firstDay || firstDay === newDayDiv) return;
                
                const firstDaySessions = firstDay.querySelectorAll('.sessions-container tr');
                const newDaySessionsContainer = newDayDiv.querySelector('.sessions-container');
                
                if (!firstDaySessions || !newDaySessionsContainer) return;
                
                firstDaySessions.forEach((sessionRow) => {
                    try {
                        const sessionCell = sessionRow.querySelector('.session-number-cell');
                        const isBreak = sessionCell && sessionCell.textContent && sessionCell.textContent.includes('Break');
                        const timeInputs = sessionRow.querySelectorAll('input[type="time"]');
                        
                        if (timeInputs && timeInputs.length >= 2 && (timeInputs[0].value || timeInputs[1].value)) {
                            if (isBreak) {
                                const button = newDayDiv.querySelector('button[onclick*="addBreak"]');
                                if (button) {
                                    addBreak(button);
                                    const newSessionRow = newDaySessionsContainer.lastElementChild;
                                    if (newSessionRow) {
                                        const newTimeInputs = newSessionRow.querySelectorAll('input[type="time"]');
                                        if (newTimeInputs && newTimeInputs.length >= 2) {
                                            newTimeInputs[0].value = timeInputs[0].value;
                                            newTimeInputs[1].value = timeInputs[1].value;
                                            calculateDurationTable(newTimeInputs[0]);
                                        }
                                    }
                                }
                            } else {
                                const button = newDayDiv.querySelector('button[onclick*="addSession"]');
                                if (button) {
                                    addSession(button);
                                    const newSessionRow = newDaySessionsContainer.lastElementChild;
                                    if (newSessionRow) {
                                        const newTimeInputs = newSessionRow.querySelectorAll('input[type="time"]');
                                        if (newTimeInputs && newTimeInputs.length >= 2) {
                                            newTimeInputs[0].value = timeInputs[0].value;
                                            newTimeInputs[1].value = timeInputs[1].value;
                                            calculateDurationTable(newTimeInputs[0]);
                                        }
                                    }
                                }
                            }
                        }
                    } catch (sessionError) {
                        console.error('Error copying session:', sessionError);
                    }
                });
            } catch (error) {
                console.error('Error copying session times from Day 1:', error);
            }
        }

        // Remove day
        function removeDay(button) {
            try {
                const dayContainer = button.closest('.day-container');
                if (dayContainer) {
                    dayContainer.remove();
                    
                    // Recount days and update headers
                    const remainingDays = document.querySelectorAll('.day-container');
                    dayCounter = remainingDays ? remainingDays.length : 0;
                    updateAllDayHeaders();
                }
            } catch (error) {
                console.error('Error removing day:', error);
                showNotification('Error removing day', 'error');
            }
        }

        // Add session
        function addSession(button) {
            const sessionsContainer = button.parentElement.parentElement.querySelector('.sessions-container');
            const sessionNumber = sessionsContainer.children.length + 1;
            const sessionRow = document.createElement('tr');
            sessionRow.className = 'fade-in';
            
            // Count only non-break sessions for numbering
            let sessionCount = 0;
            for (let i = 0; i < sessionsContainer.children.length; i++) {
                const existingCell = sessionsContainer.children[i].querySelector('.session-number-cell input');
                if (!existingCell || !existingCell.value.includes('Break')) {
                    sessionCount++;
                }
            }
            sessionCount++;
            
            const sessionText = `Session ${sessionCount}`;
            
            sessionRow.innerHTML = `
                <td class="session-number-cell">
                    <input type="text" value="${sessionText}" placeholder="Session name" onchange="updateSessionData()">
                </td>
                <td class="time-input-cell">
                    <input type="time" value="09:00" onchange="handleTimeChange(this, 'from')" onfocus="handleTimeInputFocus(this)">
                </td>
                <td class="time-input-cell">
                    <input type="time" value="10:00" onchange="handleTimeChange(this, 'to')" onfocus="handleTimeInputFocus(this)">
                </td>
                <td class="duration-cell">
                    <input type="number" class="duration-input" value="0" min="0" max="1440" placeholder="Min" onchange="handleDurationChange(this)" oninput="handleDurationChange(this)" title="Enter duration in minutes">
                </td>
                <td class="activity-cell">
                    <textarea placeholder="Enter activities and content"></textarea>
                </td>
                <td class="facilitator-cell">
                    <textarea placeholder="Enter trainer or facilitator name"></textarea>
                </td>
                <td class="actions-cell">
                    <button type="button" class="btn btn-danger" onclick="removeSessionTable(this)">‚úï</button>
                </td>
            `;
            sessionsContainer.appendChild(sessionRow);
            
            // Auto-calculate start time for new session based on previous session
            setTimeout(() => {
                autoCalculateStartTime(sessionRow);
            }, 100);
        }

        // Add break
        function addBreak(button) {
            const sessionsContainer = button.parentElement.parentElement.querySelector('.sessions-container');
            const sessionRow = document.createElement('tr');
            sessionRow.className = 'fade-in break-row';
            
            const breakText = 'Break';
            
            sessionRow.innerHTML = `
                <td class="session-number-cell">
                    <input type="text" value="${breakText}" placeholder="Break type" readonly style="background: #f0f0f0; cursor: not-allowed;">
                </td>
                <td class="time-input-cell">
                    <input type="time" value="09:00" onchange="handleTimeChange(this, 'from')" onfocus="handleTimeInputFocus(this)">
                </td>
                <td class="time-input-cell">
                    <input type="time" value="10:00" onchange="handleTimeChange(this, 'to')" onfocus="handleTimeInputFocus(this)">
                </td>
                <td class="duration-cell">
                    <input type="number" class="duration-input" value="0" min="0" max="1440" placeholder="Min" onchange="handleDurationChange(this)" oninput="handleDurationChange(this)" title="Enter duration in minutes">
                </td>
                <td class="activity-cell">
                    <input type="text" value="${breakText}" placeholder="Break type (coffee, lunch, etc.)">
                </td>
                <td class="facilitator-cell">
                    <textarea placeholder="Break notes"></textarea>
                </td>
                <td class="actions-cell">
                    <button type="button" class="btn btn-danger" onclick="removeSessionTable(this)">‚úï</button>
                </td>
            `;
            sessionsContainer.appendChild(sessionRow);
            
            // Auto-calculate start time for new break based on previous session
            setTimeout(() => {
                autoCalculateStartTime(sessionRow);
            }, 100);
        }

        // Remove session (table version)
        function removeSessionTable(button) {
            const sessionRow = button.closest('tr');
            const sessionsContainer = sessionRow.parentElement;
            sessionRow.remove();
        }

        // Update session data (called when session name changes)
        function updateSessionData() {
            // This function can be extended for additional validation or processing
        }

        // Calculate duration (table version)
        function calculateDurationTable(input) {
            const sessionRow = input.closest('tr');
            const timeInputs = sessionRow.querySelectorAll('input[type="time"]');
            const durationInput = sessionRow.querySelector('.duration-input');
            
            if (timeInputs[0].value && timeInputs[1].value) {
                const startTime = new Date('2000-01-01T' + timeInputs[0].value + ':00');
                const endTime = new Date('2000-01-01T' + timeInputs[1].value + ':00');
                let diffMs = endTime - startTime;
                
                // Handle crossing midnight
                if (diffMs < 0) {
                    diffMs += 24 * 60 * 60 * 1000;
                }
                
                const diffMins = Math.round(diffMs / (1000 * 60));
                
                if (diffMins >= 0) {
                    durationInput.value = diffMins;
                } else {
                    durationInput.value = 0;
                }
            } else {
                durationInput.value = 0;
            }
        }

        // Enhanced Smart Time Calculator - handles all time field changes
        function handleTimeChange(input, type) {
            const sessionRow = input.closest('tr');
            const timeInputs = sessionRow.querySelectorAll('input[type="time"]');
            const durationInput = sessionRow.querySelector('.duration-input');
            const fromInput = timeInputs[0];
            const toInput = timeInputs[1];
            
            // Clear validation classes
            validateTimeInput(input);
            
            if (type === 'from') {
                // When "from" time changes, calculate "to" time based on duration
                if (fromInput.value && durationInput.value && parseInt(durationInput.value) > 0) {
                    const startTime = new Date('2000-01-01T' + fromInput.value + ':00');
                    const durationMinutes = parseInt(durationInput.value);
                    const endTime = new Date(startTime.getTime() + (durationMinutes * 60 * 1000));
                    
                    const hours = endTime.getHours().toString().padStart(2, '0');
                    const minutes = endTime.getMinutes().toString().padStart(2, '0');
                    toInput.value = `${hours}:${minutes}`;
                    
                    // Visual feedback
                    toInput.classList.add('auto-calculated-end');
                    setTimeout(() => toInput.classList.remove('auto-calculated-end'), 1500);
                    
                    // Update all subsequent sessions
                    updateSubsequentSessions(sessionRow, `${hours}:${minutes}`);
                } else if (fromInput.value && toInput.value) {
                    // Calculate duration if both times are available
                    calculateDurationFromTimes(sessionRow);
                }
            } else if (type === 'to') {
                // When "to" time changes, calculate duration and update following sessions
                if (fromInput.value && toInput.value) {
                    calculateDurationFromTimes(sessionRow);
                    
                    // Update all subsequent sessions
                    updateSubsequentSessions(sessionRow, toInput.value);
                }
            }
        }

        // Enhanced duration change handler with cascade calculation
        function handleDurationChange(durationInput) {
            const sessionRow = durationInput.closest('tr');
            const timeInputs = sessionRow.querySelectorAll('input[type="time"]');
            const fromInput = timeInputs[0];
            const toInput = timeInputs[1];
            
            if (fromInput.value && durationInput.value && parseInt(durationInput.value) > 0) {
                const startTime = new Date('2000-01-01T' + fromInput.value + ':00');
                const durationMinutes = parseInt(durationInput.value);
                const endTime = new Date(startTime.getTime() + (durationMinutes * 60 * 1000));
                
                const hours = endTime.getHours().toString().padStart(2, '0');
                const minutes = endTime.getMinutes().toString().padStart(2, '0');
                toInput.value = `${hours}:${minutes}`;
                
                // Visual feedback
                toInput.classList.add('auto-calculated-end');
                setTimeout(() => toInput.classList.remove('auto-calculated-end'), 1500);
                
                // Update all subsequent sessions
                updateSubsequentSessions(sessionRow, `${hours}:${minutes}`);
            }
            
            // Check for cascade calculation opportunity
            checkCascadeCalculation(durationInput);
        }

        // New cascade calculation feature
        function checkCascadeCalculation(triggerInput) {
            const sessionsContainer = triggerInput.closest('.sessions-container');
            const allRows = Array.from(sessionsContainer.querySelectorAll('tr'));
            
            // Check if we have conditions for cascade calculation
            if (allRows.length >= 2) {
                const firstRow = allRows[0];
                const firstFromInput = firstRow.querySelector('input[type="time"]');
                
                // Check if first session has a "from" time
                if (firstFromInput && firstFromInput.value) {
                    // Count how many sessions have durations
                    let sessionsWithDurations = 0;
                    let allDurationsSet = true;
                    
                    allRows.forEach(row => {
                        const durationInput = row.querySelector('.duration-input');
                        if (durationInput && parseInt(durationInput.value) > 0) {
                            sessionsWithDurations++;
                        } else {
                            allDurationsSet = false;
                        }
                    });
                    
                    // If we have first "from" time and at least 2 durations, trigger cascade
                    if (sessionsWithDurations >= 2) {
                        performCascadeCalculation(sessionsContainer);
                    }
                }
            }
        }

        // Perform cascade calculation for entire schedule
        function performCascadeCalculation(sessionsContainer) {
            const allRows = Array.from(sessionsContainer.querySelectorAll('tr'));
            let currentEndTime = '';
            
            allRows.forEach((row, index) => {
                const timeInputs = row.querySelectorAll('input[type="time"]');
                const durationInput = row.querySelector('.duration-input');
                const fromInput = timeInputs[0];
                const toInput = timeInputs[1];
                
                if (durationInput && parseInt(durationInput.value) > 0) {
                    // For first session, use existing "from" time
                    if (index === 0 && fromInput.value) {
                        currentEndTime = calculateEndTimeFromStartAndDuration(fromInput.value, parseInt(durationInput.value));
                        toInput.value = currentEndTime;
                        
                        // Visual feedback
                        toInput.classList.add('auto-calculated-end');
                        setTimeout(() => toInput.classList.remove('auto-calculated-end'), 1500);
                    }
                    // For subsequent sessions, set "from" time to previous "to" time
                    else if (index > 0 && currentEndTime) {
                        fromInput.value = currentEndTime;
                        
                        // Visual feedback for auto-calculated start time
                        fromInput.classList.add('auto-calculated-start');
                        setTimeout(() => fromInput.classList.remove('auto-calculated-start'), 1500);
                        
                        // Calculate new end time
                        currentEndTime = calculateEndTimeFromStartAndDuration(fromInput.value, parseInt(durationInput.value));
                        toInput.value = currentEndTime;
                        
                        // Visual feedback for auto-calculated end time
                        toInput.classList.add('auto-calculated-end');
                        setTimeout(() => toInput.classList.remove('auto-calculated-end'), 1500);
                    }
                }
            });
            
            // Show cascade calculation notification
            showCascadeNotification();
        }

        // Helper function to calculate end time from start time and duration
        function calculateEndTimeFromStartAndDuration(startTime, durationMinutes) {
            const startDateTime = new Date('2000-01-01T' + startTime + ':00');
            const endDateTime = new Date(startDateTime.getTime() + (durationMinutes * 60 * 1000));
            
            const hours = endDateTime.getHours().toString().padStart(2, '0');
            const minutes = endDateTime.getMinutes().toString().padStart(2, '0');
            
            return `${hours}:${minutes}`;
        }

        // Show cascade calculation notification
        function showCascadeNotification() {
            showNotification('üöÄ Complete schedule auto-generated from start time and durations!', 'success');
        }

        // Calculate duration from start and end times
        function calculateDurationFromTimes(sessionRow) {
            const timeInputs = sessionRow.querySelectorAll('input[type="time"]');
            const durationInput = sessionRow.querySelector('.duration-input');
            const fromInput = timeInputs[0];
            const toInput = timeInputs[1];
            
            if (fromInput.value && toInput.value) {
                const startTime = new Date('2000-01-01T' + fromInput.value + ':00');
                const endTime = new Date('2000-01-01T' + toInput.value + ':00');
                let diffMs = endTime - startTime;
                
                // Handle crossing midnight
                if (diffMs < 0) {
                    diffMs += 24 * 60 * 60 * 1000;
                }
                
                const diffMins = Math.round(diffMs / (1000 * 60));
                
                if (diffMins >= 0) {
                    durationInput.value = diffMins;
                    
                    // Visual feedback for auto-calculated duration
                    durationInput.classList.add('auto-calculated-end');
                    setTimeout(() => durationInput.classList.remove('auto-calculated-end'), 1500);
                } else {
                    durationInput.value = 0;
                }
            }
        }

        // Simple duration calculation for loading data (no chain reaction)
        function calculateDurationTable(input) {
            const sessionRow = input.closest('tr');
            const timeInputs = sessionRow.querySelectorAll('input[type="time"]');
            const durationInput = sessionRow.querySelector('.duration-input');
            
            if (timeInputs[0].value && timeInputs[1].value) {
                const startTime = new Date('2000-01-01T' + timeInputs[0].value + ':00');
                const endTime = new Date('2000-01-01T' + timeInputs[1].value + ':00');
                let diffMs = endTime - startTime;
                
                // Handle crossing midnight
                if (diffMs < 0) {
                    diffMs += 24 * 60 * 60 * 1000;
                }
                
                const diffMins = Math.round(diffMs / (1000 * 60));
                
                if (diffMins >= 0) {
                    durationInput.value = diffMins;
                } else {
                    durationInput.value = 0;
                }
            } else {
                durationInput.value = 0;
            }
        }

        // Update all subsequent sessions when a duration changes
        function updateSubsequentSessions(currentSessionRow, newEndTime) {
            const sessionsContainer = currentSessionRow.closest('.sessions-container');
            const allRows = Array.from(sessionsContainer.querySelectorAll('tr'));
            const currentIndex = allRows.indexOf(currentSessionRow);
            
            let lastEndTime = newEndTime;
            
            // Add chain reaction indicator
            currentSessionRow.classList.add('chain-reaction-active');
            setTimeout(() => {
                currentSessionRow.classList.remove('chain-reaction-active');
            }, 2000);
            
            // Update all sessions after the current one
            for (let i = currentIndex + 1; i < allRows.length; i++) {
                const nextRow = allRows[i];
                const nextTimeInputs = nextRow.querySelectorAll('input[type="time"]');
                const nextDurationInput = nextRow.querySelector('.duration-input');
                
                if (nextTimeInputs.length >= 2 && nextDurationInput) {
                    // Set start time to be the end time of previous session
                    nextTimeInputs[0].value = lastEndTime;
                    
                    // Add visual feedback for auto-calculated start time
                    nextTimeInputs[0].classList.add('auto-calculated-start');
                    setTimeout(() => {
                        nextTimeInputs[0].classList.remove('auto-calculated-start');
                    }, 1500);
                    
                    // Calculate new end time if duration is set
                    const duration = parseInt(nextDurationInput.value);
                    if (duration > 0) {
                        const startTime = new Date('2000-01-01T' + lastEndTime + ':00');
                        const endTime = new Date(startTime.getTime() + (duration * 60 * 1000));
                        
                        const hours = endTime.getHours().toString().padStart(2, '0');
                        const minutes = endTime.getMinutes().toString().padStart(2, '0');
                        
                        nextTimeInputs[1].value = `${hours}:${minutes}`;
                        lastEndTime = `${hours}:${minutes}`;
                        
                        // Add visual feedback for auto-calculated end time
                        nextTimeInputs[1].classList.add('auto-calculated-end');
                        setTimeout(() => {
                            nextTimeInputs[1].classList.remove('auto-calculated-end');
                        }, 1500);
                    } else {
                        // If no duration is set, end time becomes the start time (0 duration)
                        nextTimeInputs[1].value = lastEndTime;
                    }
                }
            }
        }

        // Auto-calculate session start time based on previous session
        function autoCalculateStartTime(sessionRow) {
            const sessionsContainer = sessionRow.closest('.sessions-container');
            const allRows = Array.from(sessionsContainer.querySelectorAll('tr'));
            const currentIndex = allRows.indexOf(sessionRow);
            
            // If this is not the first session, set start time based on previous session
            if (currentIndex > 0) {
                const previousRow = allRows[currentIndex - 1];
                const previousTimeInputs = previousRow.querySelectorAll('input[type="time"]');
                const currentTimeInputs = sessionRow.querySelectorAll('input[type="time"]');
                
                if (previousTimeInputs.length >= 2 && previousTimeInputs[1].value && currentTimeInputs.length >= 1) {
                    currentTimeInputs[0].value = previousTimeInputs[1].value;
                    
                    // Add visual feedback
                    currentTimeInputs[0].classList.add('auto-calculated-start');
                    setTimeout(() => {
                        currentTimeInputs[0].classList.remove('auto-calculated-start');
                    }, 1000);
                    
                    // If duration is already set, calculate end time using new system
                    const durationInput = sessionRow.querySelector('.duration-input');
                    if (durationInput && parseInt(durationInput.value) > 0) {
                        handleDurationChange(durationInput);
                    }
                }
            }
        }

        // Add helper function to validate time inputs
        function validateTimeInput(input) {
            const sessionRow = input.closest('tr');
            const timeInputs = sessionRow.querySelectorAll('input[type="time"]');
            
            // Clear any auto-calculated background
            timeInputs.forEach(timeInput => {
                timeInput.classList.remove('auto-calculated-start', 'auto-calculated-end');
            });
        }

        // Handle time input focus to provide smart guidance
        function handleTimeInputFocus(input) {
            const sessionRow = input.closest('tr');
            const sessionsContainer = sessionRow.closest('.sessions-container');
            const allRows = Array.from(sessionsContainer.querySelectorAll('tr'));
            const currentIndex = allRows.indexOf(sessionRow);
            const timeInputs = sessionRow.querySelectorAll('input[type="time"]');
            const isFromInput = input === timeInputs[0];
            const isToInput = input === timeInputs[1];
            
            // For any session "from" input
            if (isFromInput) {
                input.title = 'Change start time and end time + all following sessions will update automatically';
            }
            // For any session "to" input
            else if (isToInput) {
                input.title = 'Change end time and duration will be calculated + all following sessions will update automatically';
            }
        }

        // Clear all details in a specific day
        function clearDayDetails(button) {
            if (confirm('Are you sure you want to clear all sessions and breaks in this day?')) {
                try {
                    const dayContainer = button.closest('.day-container');
                    if (!dayContainer) {
                        showNotification('Error: Day container not found', 'error');
                        return;
                    }
                    
                    const sessionsContainer = dayContainer.querySelector('.sessions-container');
                    if (!sessionsContainer) {
                        showNotification('Error: Sessions container not found', 'error');
                        return;
                    }
                    
                    // Clear all sessions and breaks
                    sessionsContainer.innerHTML = '';
                    
                    // Show success feedback
                    button.style.background = '#28a745';
                    button.style.color = 'white';
                    button.innerHTML = '<span>‚úì</span><span>Cleared</span>';
                    
                    setTimeout(() => {
                        button.style.background = '#dc3545';
                        button.style.color = 'white';
                        button.innerHTML = '<span>üóëÔ∏è</span><span>Clear Details</span>';
                    }, 1500);
                    
                    showNotification('Day details cleared successfully!', 'success');
                } catch (error) {
                    console.error('Error clearing day details:', error);
                    showNotification('Error clearing day details', 'error');
                }
            }
        }

        // Collect data from form
        function collectData() {
            try {
                const data = {
                    title: document.getElementById('workshopTitle')?.value || '',
                    dateFrom: document.getElementById('workshopDateFrom')?.value || '',
                    dateTo: document.getElementById('workshopDateTo')?.value || '',
                    location: document.getElementById('workshopLocation')?.value || '',
                    address: document.getElementById('workshopAddress')?.value || '',
                    venue: document.getElementById('workshopVenue')?.value || '',
                    type: document.querySelector('input[name="workshopType"]:checked')?.value || 'face-to-face',
                    platformName: document.getElementById('platformName')?.value || '',
                    registrationLink: document.getElementById('registrationLink')?.value || '',
                    contact: {
                        facilitatorName: document.getElementById('facilitatorName')?.value || '',
                        phone: document.getElementById('facilitatorPhone')?.value || '',
                        email: document.getElementById('facilitatorEmail')?.value || ''
                    },
                    objectives: [],
                    outcomes: [],
                    days: [],
                    notes: document.getElementById('participantNotes')?.value || ''
                };

                // Collect objectives
                const objectivesInputs = document.querySelectorAll('#objectivesList input');
                if (objectivesInputs) {
                    objectivesInputs.forEach(input => {
                        if (input && input.value && input.value.trim()) {
                            data.objectives.push(input.value.trim());
                        }
                    });
                }

                // Collect outcomes
                const outcomesInputs = document.querySelectorAll('#outcomesList input');
                if (outcomesInputs) {
                    outcomesInputs.forEach(input => {
                        if (input && input.value && input.value.trim()) {
                            data.outcomes.push(input.value.trim());
                        }
                    });
                }

                // Collect days
                const dayContainers = document.querySelectorAll('.day-container');
                if (dayContainers) {
                    dayContainers.forEach((dayEl, dayIndex) => {
                        const day = {
                            number: dayIndex + 1,
                            sessions: []
                        };

                        const sessionRows = dayEl.querySelectorAll('.sessions-container tr');
                        if (sessionRows) {
                            sessionRows.forEach((sessionRow, sessionIndex) => {
                                try {
                                    const timeInputs = sessionRow.querySelectorAll('input[type="time"]');
                                    const sessionCell = sessionRow.querySelector('.session-number-cell input');
                                    const isBreak = sessionCell && sessionCell.value && sessionCell.value.includes('Break');
                                    const durationInput = sessionRow.querySelector('.duration-input');
                                    
                                    const session = {
                                        number: isBreak ? 'Break' : sessionIndex + 1,
                                        sessionName: sessionCell ? sessionCell.value : '',
                                        timeFrom: timeInputs && timeInputs[0] ? timeInputs[0].value : '',
                                        timeTo: timeInputs && timeInputs[1] ? timeInputs[1].value : '',
                                        duration: (durationInput ? durationInput.value : '0') + ' min',
                                        isBreak: isBreak
                                    };

                                    if (isBreak) {
                                        const activityInput = sessionRow.querySelector('.activity-cell input');
                                        const facilitatorTextarea = sessionRow.querySelector('.facilitator-cell textarea');
                                        session.breakType = activityInput ? activityInput.value : '';
                                        session.notes = facilitatorTextarea ? facilitatorTextarea.value : '';
                                    } else {
                                        const textarea = sessionRow.querySelector('.activity-cell textarea');
                                        const facilitatorTextarea = sessionRow.querySelector('.facilitator-cell textarea');
                                        session.activities = textarea ? textarea.value : '';
                                        session.facilitator = facilitatorTextarea ? facilitatorTextarea.value : '';
                                    }

                                    day.sessions.push(session);
                                } catch (sessionError) {
                                    console.error('Error collecting session data:', sessionError);
                                }
                            });
                        }

                        data.days.push(day);
                    });
                }

                return data;
            } catch (error) {
                console.error('Error collecting data:', error);
                showNotification('Error collecting form data', 'error');
                return {
                    title: '',
                    dateFrom: '',
                    dateTo: '',
                    location: '',
                    objectives: [],
                    outcomes: [],
                    days: [],
                    notes: ''
                };
            }
        }

        // Save data to memory
        function saveData() {
            workshopData = collectData();
            showNotification('Data saved successfully!', 'success');
        }

        // Export as JSON
        function exportJSON() {
            const data = collectData();
            const jsonString = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `workshop-agenda-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showNotification('JSON file exported successfully!', 'success');
        }

        // Export as Word
        async function exportWord() {
            // Check if docx library is loaded
            if (typeof window.docx === 'undefined') {
                showNotification('Export library is still loading. Please wait a moment and try again.', 'error');
                return;
            }

            const data = collectData();
            
            try {
                const { Document, Paragraph, TextRun, Table, TableRow, TableCell, 
                        AlignmentType, WidthType, BorderStyle, ShadingType, Packer, HeadingLevel } = window.docx;

                // Format date range
                let dateRange = '';
                if (data.dateFrom && data.dateTo) {
                    dateRange = data.dateFrom === data.dateTo ? data.dateFrom : `${data.dateFrom} to ${data.dateTo}`;
                } else {
                    dateRange = data.dateFrom || data.dateTo || 'Not specified';
                }
                
                // Format title
                const workshopTitle = data.title && data.title.trim() ? `${data.title} Workshop` : 'Workshop';

                // Build document content
                const children = [];

                // Title
                children.push(new Paragraph({
                    children: [new TextRun({ text: workshopTitle, size: 36, bold: true })],
                    alignment: AlignmentType.CENTER,
                    spacing: { after: 200 }
                }));

                // Workshop info
                let infoText = `Date: ${dateRange}`;
                if (data.location) infoText += ` | Location: ${data.location}`;
                if (data.type === 'online' && data.platformName) infoText += ` | Platform: ${data.platformName}`;
                
                children.push(new Paragraph({
                    children: [new TextRun({ text: infoText, size: 22 })],
                    alignment: AlignmentType.CENTER,
                    spacing: { after: 200 }
                }));

                // Additional info
                if (data.address) {
                    children.push(new Paragraph({
                        children: [new TextRun({ text: `Full Address: ${data.address}`, size: 22 })],
                        alignment: AlignmentType.CENTER,
                        spacing: { after: 100 }
                    }));
                }

                if (data.venue) {
                    children.push(new Paragraph({
                        children: [new TextRun({ text: `Venue Details: ${data.venue}`, size: 22 })],
                        alignment: AlignmentType.CENTER,
                        spacing: { after: 100 }
                    }));
                }

                // Contact info
                const contact = data.contact || {};
                if (contact.facilitatorName || contact.phone || contact.email) {
                    let contactText = '';
                    if (contact.facilitatorName) contactText += `Facilitator: ${contact.facilitatorName}`;
                    if (contact.phone) contactText += (contactText ? ' | ' : '') + `Phone: ${contact.phone}`;
                    if (contact.email) contactText += (contactText ? ' | ' : '') + `Email: ${contact.email}`;
                    
                    children.push(new Paragraph({
                        children: [new TextRun({ text: contactText, size: 22 })],
                        alignment: AlignmentType.CENTER,
                        spacing: { after: 300 }
                    }));
                }

                // Objectives
                if (data.objectives && data.objectives.length > 0) {
                    children.push(new Paragraph({
                        children: [new TextRun({ text: 'Objectives', size: 28, bold: true })],
                        alignment: AlignmentType.LEFT,
                        bidirectional: false,
                        spacing: { before: 240, after: 120 }
                    }));
                    
                    data.objectives.forEach(obj => {
                        if (obj.trim()) {
                            children.push(new Paragraph({
                                children: [new TextRun({ text: `‚Ä¢ ${obj}`, size: 22 })],
                                alignment: AlignmentType.LEFT,
                                bidirectional: false,
                                spacing: { after: 60 }
                            }));
                        }
                    });
                }

                // Outcomes
                if (data.outcomes && data.outcomes.length > 0) {
                    children.push(new Paragraph({
                        children: [new TextRun({ text: 'Expected Outcomes', size: 28, bold: true })],
                        alignment: AlignmentType.LEFT,
                        bidirectional: false,
                        spacing: { before: 240, after: 120 }
                    }));
                    
                    data.outcomes.forEach(outcome => {
                        if (outcome.trim()) {
                            children.push(new Paragraph({
                                children: [new TextRun({ text: `‚Ä¢ ${outcome}`, size: 22 })],
                                alignment: AlignmentType.LEFT,
                                bidirectional: false,
                                spacing: { after: 60 }
                            }));
                        }
                    });
                }

                // Days and tables
                (data.days || []).forEach((day, dayIndex) => {
                    if (dayIndex > 0) {
                        children.push(new Paragraph({ text: '', pageBreakBefore: true }));
                    }

                    const dayHeader = formatDayDate(dayIndex);
                    children.push(new Paragraph({
                        children: [new TextRun({ text: `${dayHeader} - Agenda`, size: 26, bold: true })],
                        alignment: AlignmentType.LEFT,
                        bidirectional: false,
                        spacing: { before: 240, after: 120 }
                    }));

                    if (day.sessions && day.sessions.length > 0) {
                        const tableRows = [];
                        
                        // Header row
                        tableRows.push(new TableRow({
                            tableHeader: true,
                            children: [
                                new TableCell({ children: [new Paragraph({ text: 'Session', alignment: AlignmentType.CENTER, bidirectional: false })], width: { size: 18, type: WidthType.PERCENTAGE }, shading: { fill: 'D9D9D9' } }),
                                new TableCell({ children: [new Paragraph({ text: 'From', alignment: AlignmentType.CENTER, bidirectional: false })], width: { size: 10, type: WidthType.PERCENTAGE }, shading: { fill: 'D9D9D9' } }),
                                new TableCell({ children: [new Paragraph({ text: 'To', alignment: AlignmentType.CENTER, bidirectional: false })], width: { size: 10, type: WidthType.PERCENTAGE }, shading: { fill: 'D9D9D9' } }),
                                new TableCell({ children: [new Paragraph({ text: 'Duration (min)', alignment: AlignmentType.CENTER, bidirectional: false })], width: { size: 8, type: WidthType.PERCENTAGE }, shading: { fill: 'D9D9D9' } }),
                                new TableCell({ children: [new Paragraph({ text: 'Activities', alignment: AlignmentType.CENTER, bidirectional: false })], width: { size: 30, type: WidthType.PERCENTAGE }, shading: { fill: 'D9D9D9' } }),
                                new TableCell({ children: [new Paragraph({ text: 'Facilitator(s)', alignment: AlignmentType.CENTER, bidirectional: false })], width: { size: 24, type: WidthType.PERCENTAGE }, shading: { fill: 'D9D9D9' } })
                            ]
                        }));

                        // Data rows
                        day.sessions.forEach(session => {
                            const sessionName = session.sessionName || (session.isBreak ? 'Break' : `Session ${session.number}`);
                            const activities = session.isBreak ? (session.breakType || 'Break') : (session.activities || '');
                            const facilitator = session.isBreak ? (session.notes || '') : (session.facilitator || '');
                            const duration = String(parseInt(session.duration) || 0);
                            
                            const shading = session.isBreak ? { fill: 'F5F5F5' } : undefined;

                            tableRows.push(new TableRow({
                                children: [
                                    new TableCell({ children: [new Paragraph({ text: sessionName, alignment: AlignmentType.LEFT, bidirectional: false })], shading }),
                                    new TableCell({ children: [new Paragraph({ text: session.timeFrom || '-', alignment: AlignmentType.CENTER, bidirectional: false })], shading }),
                                    new TableCell({ children: [new Paragraph({ text: session.timeTo || '-', alignment: AlignmentType.CENTER, bidirectional: false })], shading }),
                                    new TableCell({ children: [new Paragraph({ text: duration, alignment: AlignmentType.CENTER, bidirectional: false })], shading }),
                                    new TableCell({ children: [new Paragraph({ text: activities, alignment: AlignmentType.LEFT, bidirectional: false })], shading }),
                                    new TableCell({ children: [new Paragraph({ text: facilitator, alignment: AlignmentType.LEFT, bidirectional: false })], shading })
                                ]
                            }));
                        });

                        children.push(new Table({
                            rows: tableRows,
                            width: { size: 100, type: WidthType.PERCENTAGE },
                            margins: { top: 100, bottom: 100, left: 100, right: 100 }
                        }));
                    }
                });

                // Notes
                if (data.notes && data.notes.trim()) {
                    children.push(new Paragraph({
                        children: [new TextRun({ text: 'Participant Notes', size: 28, bold: true })],
                        alignment: AlignmentType.LEFT,
                        bidirectional: false,
                        spacing: { before: 300, after: 120 }
                    }));
                    
                    data.notes.split('\n').forEach(line => {
                        if (line.trim()) {
                            children.push(new Paragraph({
                                children: [new TextRun({ text: line, size: 22 })],
                                alignment: AlignmentType.LEFT,
                                bidirectional: false,
                                spacing: { after: 60 }
                            }));
                        }
                    });
                }

                // Create document
                const doc = new Document({
                    sections: [{
                        properties: {
                            page: {
                                margin: { top: 1440, right: 1080, bottom: 1440, left: 1080 }
                            }
                        },
                        children: children
                    }]
                });

                // Generate and download
                const blob = await Packer.toBlob(doc);
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `workshop-agenda-${new Date().toISOString().split('T')[0]}.docx`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                showNotification('Word document exported successfully!', 'success');

            } catch (error) {
                console.error('Export error:', error);
                showNotification('Export error: ' + error.message, 'error');
            }
        }

        // Load data from file
        function loadData(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Show loading notification
            showNotification('Loading file...', 'info');

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    
                    // Validate basic structure
                    if (typeof data !== 'object' || data === null) {
                        throw new Error('Invalid file format');
                    }
                    
                    // Populate form with the data
                    populateForm(data);
                    
                    // Success notification
                    showNotification('Data loaded successfully!', 'success');
                    
                } catch (error) {
                    console.error('Error loading file:', error);
                    
                    if (error instanceof SyntaxError) {
                        showNotification('Invalid JSON file format!', 'error');
                    } else {
                        showNotification('Error loading file: ' + error.message, 'error');
                    }
                }
            };
            
            reader.onerror = function() {
                showNotification('Error reading file!', 'error');
            };
            
            reader.readAsText(file);
            
            // Clear the input so the same file can be loaded again if needed
            event.target.value = '';
        }

        // Populate form with loaded data
        function populateForm(data) {
            try {
                // Clear existing content with error checking
                const workshopTitle = document.getElementById('workshopTitle');
                const workshopDateFrom = document.getElementById('workshopDateFrom');
                const workshopDateTo = document.getElementById('workshopDateTo');
                const workshopLocation = document.getElementById('workshopLocation');
                const workshopAddress = document.getElementById('workshopAddress');
                const workshopVenue = document.getElementById('workshopVenue');
                const registrationLink = document.getElementById('registrationLink');
                const platformName = document.getElementById('platformName');
                const participantNotes = document.getElementById('participantNotes');
                
                if (workshopTitle) workshopTitle.value = data.title || '';
                if (workshopDateFrom) workshopDateFrom.value = data.dateFrom || data.date || '';
                if (workshopDateTo) workshopDateTo.value = data.dateTo || data.date || '';
                if (workshopLocation) workshopLocation.value = data.location || '';
                if (workshopAddress) workshopAddress.value = data.address || '';
                if (workshopVenue) workshopVenue.value = data.venue || '';
                if (registrationLink) registrationLink.value = data.registrationLink || '';
                if (platformName) platformName.value = data.platformName || '';
                if (participantNotes) participantNotes.value = data.notes || '';
                
                // Set workshop type
                const typeOnline = document.getElementById('typeOnline');
                const typeFaceToFace = document.getElementById('typeFaceToFace');
                
                if (typeOnline && typeFaceToFace) {
                    if (data.type === 'online') {
                        typeOnline.checked = true;
                        typeFaceToFace.checked = false;
                    } else {
                        typeFaceToFace.checked = true;
                        typeOnline.checked = false;
                    }
                    toggleOnlineFields();
                }
                
                // Load contact information
                const facilitatorName = document.getElementById('facilitatorName');
                const facilitatorPhone = document.getElementById('facilitatorPhone');
                const facilitatorEmail = document.getElementById('facilitatorEmail');
                
                if (data.contact) {
                    if (facilitatorName) facilitatorName.value = data.contact.facilitatorName || '';
                    if (facilitatorPhone) facilitatorPhone.value = data.contact.phone || '';
                    if (facilitatorEmail) facilitatorEmail.value = data.contact.email || '';
                } else {
                    if (facilitatorName) facilitatorName.value = '';
                    if (facilitatorPhone) facilitatorPhone.value = '';
                    if (facilitatorEmail) facilitatorEmail.value = '';
                }

                // Clear and populate objectives
                const objectivesList = document.getElementById('objectivesList');
                if (objectivesList) {
                    objectivesList.innerHTML = '';
                    if (data.objectives && data.objectives.length > 0) {
                        data.objectives.forEach(obj => {
                            if (obj && obj.trim()) {
                                const item = document.createElement('div');
                                item.className = 'list-item';
                                item.innerHTML = `
                                    <input type="text" value="${obj.replace(/"/g, '&quot;')}">
                                    <button type="button" class="btn btn-danger" onclick="removeItem(this)">‚úï</button>
                                `;
                                objectivesList.appendChild(item);
                            }
                        });
                    } else {
                        objectivesList.innerHTML = '<div class="list-item"><input type="text" placeholder="Enter objective"><button type="button" class="btn btn-danger" onclick="removeItem(this)">‚úï</button></div>';
                    }
                }

                // Clear and populate outcomes
                const outcomesList = document.getElementById('outcomesList');
                if (outcomesList) {
                    outcomesList.innerHTML = '';
                    if (data.outcomes && data.outcomes.length > 0) {
                        data.outcomes.forEach(outcome => {
                            if (outcome && outcome.trim()) {
                                const item = document.createElement('div');
                                item.className = 'list-item';
                                item.innerHTML = `
                                    <input type="text" value="${outcome.replace(/"/g, '&quot;')}">
                                    <button type="button" class="btn btn-danger" onclick="removeItem(this)">‚úï</button>
                                `;
                                outcomesList.appendChild(item);
                            }
                        });
                    } else {
                        outcomesList.innerHTML = '<div class="list-item"><input type="text" placeholder="Enter expected outcome"><button type="button" class="btn btn-danger" onclick="removeItem(this)">‚úï</button></div>';
                    }
                }

                // Clear and populate days
                const daysContainer = document.getElementById('daysContainer');
                if (!daysContainer) {
                    throw new Error('Days container not found');
                }
                
                daysContainer.innerHTML = '';
                dayCounter = 0;

                if (data.days && data.days.length > 0) {
                    data.days.forEach((day, dayIndex) => {
                        addDay();
                        
                        // Wait for DOM to update
                        setTimeout(() => {
                            const dayEl = daysContainer.lastElementChild;
                            if (!dayEl) {
                                console.error('Day element not found after creation');
                                return;
                            }
                            
                            const sessionsContainer = dayEl.querySelector('.sessions-container');
                            if (!sessionsContainer) {
                                console.error('Sessions container not found in day element');
                                return;
                            }
                            
                            sessionsContainer.innerHTML = '';

                            if (day.sessions && day.sessions.length > 0) {
                                day.sessions.forEach((session, sessionIndex) => {
                                    // Wait a bit more for each session to ensure DOM is ready
                                    setTimeout(() => {
                                        try {
                                            if (session.isBreak) {
                                                const button = dayEl.querySelector('button[onclick*="addBreak"]');
                                                if (button) {
                                                    addBreak(button);
                                                    
                                                    setTimeout(() => {
                                                        const sessionRow = sessionsContainer.lastElementChild;
                                                        if (sessionRow) {
                                                            populateBreakSession(sessionRow, session);
                                                        }
                                                    }, 50);
                                                }
                                            } else {
                                                const button = dayEl.querySelector('button[onclick*="addSession"]');
                                                if (button) {
                                                    addSession(button);
                                                    
                                                    setTimeout(() => {
                                                        const sessionRow = sessionsContainer.lastElementChild;
                                                        if (sessionRow) {
                                                            populateRegularSession(sessionRow, session);
                                                        }
                                                    }, 50);
                                                }
                                            }
                                        } catch (sessionError) {
                                            console.error('Error creating session:', sessionError);
                                        }
                                    }, sessionIndex * 100); // Stagger session creation
                                });
                            }
                        }, dayIndex * 200); // Stagger day creation
                    });
                } else {
                    // Add default day if no days in data
                    addDay();
                    setTimeout(() => {
                        const firstDayButton = document.querySelector('button[onclick*="addSession"]');
                        if (firstDayButton) {
                            addSession(firstDayButton);
                        }
                    }, 100);
                }
                
                // Update day headers with correct dates after loading (with delay)
                setTimeout(() => {
                    updateAllDayHeaders();
                }, 1000);
                
            } catch (error) {
                console.error('Error in populateForm:', error);
                showNotification('Error loading some data. Please check the file format.', 'warning');
            }
        }

        // Helper function to populate break session
        function populateBreakSession(sessionRow, session) {
            try {
                const timeInputs = sessionRow.querySelectorAll('input[type="time"]');
                const sessionNameInput = sessionRow.querySelector('.session-number-cell input');
                const activityInput = sessionRow.querySelector('.activity-cell input');
                const facilitatorTextarea = sessionRow.querySelector('.facilitator-cell textarea');
                const durationInput = sessionRow.querySelector('.duration-input');
                
                if (timeInputs && timeInputs.length >= 2) {
                    if (timeInputs[0]) timeInputs[0].value = session.timeFrom || '';
                    if (timeInputs[1]) timeInputs[1].value = session.timeTo || '';
                }
                
                if (session.sessionName && sessionNameInput) {
                    sessionNameInput.value = session.sessionName;
                }
                
                if (activityInput) {
                    activityInput.value = session.breakType || 'Break';
                }
                
                if (facilitatorTextarea) {
                    facilitatorTextarea.value = session.notes || '';
                }
                
                if (durationInput) {
                    durationInput.value = parseInt(session.duration) || 0;
                }
                
                // Calculate duration if time inputs are available
                if (timeInputs && timeInputs[0] && timeInputs[0].value && timeInputs[1] && timeInputs[1].value) {
                    calculateDurationTable(timeInputs[0]);
                }
            } catch (error) {
                console.error('Error populating break session:', error);
            }
        }

        // Helper function to populate regular session
        function populateRegularSession(sessionRow, session) {
            try {
                const timeInputs = sessionRow.querySelectorAll('input[type="time"]');
                const sessionNameInput = sessionRow.querySelector('.session-number-cell input');
                const textarea = sessionRow.querySelector('.activity-cell textarea');
                const facilitatorTextarea = sessionRow.querySelector('.facilitator-cell textarea');
                const durationInput = sessionRow.querySelector('.duration-input');
                
                if (timeInputs && timeInputs.length >= 2) {
                    if (timeInputs[0]) timeInputs[0].value = session.timeFrom || '';
                    if (timeInputs[1]) timeInputs[1].value = session.timeTo || '';
                }
                
                if (session.sessionName && sessionNameInput) {
                    sessionNameInput.value = session.sessionName;
                }
                
                if (textarea) {
                    textarea.value = session.activities || '';
                }
                
                if (facilitatorTextarea) {
                    facilitatorTextarea.value = session.facilitator || '';
                }
                
                if (durationInput) {
                    durationInput.value = parseInt(session.duration) || 0;
                }
                
                // Calculate duration if time inputs are available
                if (timeInputs && timeInputs[0] && timeInputs[0].value && timeInputs[1] && timeInputs[1].value) {
                    calculateDurationTable(timeInputs[0]);
                }
            } catch (error) {
                console.error('Error populating regular session:', error);
            }
        }

        // Generate LinkedIn Post
        function generateLinkedInPost() {
            const data = collectData();
            
            // Get first session time for workshop timing
            let workshopTime = '';
            if (data.days && data.days.length > 0 && data.days[0].sessions && data.days[0].sessions.length > 0) {
                const firstSession = data.days[0].sessions.find(session => !session.isBreak);
                if (firstSession && firstSession.timeFrom) {
                    workshopTime = firstSession.timeFrom;
                }
            }
            
            // Format date range
            let dateRange = '';
            if (data.dateFrom && data.dateTo) {
                if (data.dateFrom === data.dateTo) {
                    dateRange = data.dateFrom;
                } else {
                    dateRange = `${data.dateFrom} to ${data.dateTo}`;
                }
            } else if (data.dateFrom) {
                dateRange = data.dateFrom;
            } else {
                dateRange = 'Coming Soon';
            }
            
            // Combine objectives and outcomes for goals section
            let goalsSection = '';
            if (data.objectives && data.objectives.length > 0) {
                const objectives = data.objectives.slice(0, 3).join('\n‚Ä¢ '); // Limit to 3 for brevity
                goalsSection += `\nüéØ Workshop Goals:\n‚Ä¢ ${objectives}`;
            }
            
            if (data.outcomes && data.outcomes.length > 0) {
                const outcomes = data.outcomes.slice(0, 2).join('\n‚Ä¢ '); // Limit to 2 for brevity
                goalsSection += `\n\n‚ú® Expected Results:\n‚Ä¢ ${outcomes}`;
            }
            
            // Generate registration link section
            let registrationSection = '';
            if (data.type === 'online' && data.registrationLink && data.registrationLink.trim()) {
                registrationSection = `\nüîó Register now: ${data.registrationLink.trim()}`;
            } else {
                registrationSection = `\nüîó Register now: [Registration Link]`;
            }
            
            // Add location/type information
            let locationSection = '';
            if (data.location && data.location.trim()) {
                if (data.type === 'online') {
                    locationSection = data.platformName && data.platformName.trim() 
                        ? `\nüíª Online Workshop (${data.platformName.trim()})`
                        : `\nüíª Online Workshop`;
                } else {
                    locationSection = `\nüìç Location: ${data.location}`;
                }
            } else if (data.type === 'online') {
                locationSection = data.platformName && data.platformName.trim() 
                    ? `\nüíª Online Workshop (${data.platformName.trim()})`
                    : `\nüíª Online Workshop`;
            }
            
            // Generate LinkedIn post content
            const linkedInPost = `Dears
Greetings
our upcoming workshop: "${data.title || 'Training Workshop'}"
üìÖ Date: ${dateRange}${workshopTime ? `\nüïê Time: ${workshopTime}` : ''}${locationSection}${goalsSection}${registrationSection}

#Training #Workshop #ProfessionalDevelopment #Learning`;
            
            // Create and show modal
            createLinkedInModal(linkedInPost);
        }

        // Create LinkedIn Modal
        function createLinkedInModal(postContent) {
            // Remove existing modal if any
            const existingModal = document.getElementById('linkedinModal');
            if (existingModal) {
                existingModal.remove();
            }
            
            // Create modal
            const modal = document.createElement('div');
            modal.id = 'linkedinModal';
            modal.className = 'linkedin-modal';
            modal.innerHTML = `
                <div class="linkedin-modal-content">
                    <h3>
                        <span>üíº</span>
                        <span>LinkedIn Post</span>
                    </h3>
                    <p style="margin-bottom: 15px; color: #666; font-size: 0.9rem;">
                        Copy the text below and paste it into your LinkedIn post:
                    </p>
                    <div class="linkedin-post-content" id="linkedinPostContent">${postContent}</div>
                    <div class="linkedin-modal-actions">
                        <button class="btn btn-primary" onclick="copyLinkedInPost()">
                            <span>üìã</span>
                            <span>Copy Text</span>
                        </button>
                        <button class="btn btn-success" onclick="openLinkedIn()">
                            <span>üíº</span>
                            <span>Open LinkedIn</span>
                        </button>
                        <button class="btn btn-secondary" onclick="closeLinkedInModal()">
                            <span>Close</span>
                        </button>
                    </div>
                </div>
            `;
            
            // Add modal to page
            document.body.appendChild(modal);
            
            // Close modal when clicking outside
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    closeLinkedInModal();
                }
            });
        }

        // Copy LinkedIn post to clipboard
        function copyLinkedInPost() {
            const postContent = document.getElementById('linkedinPostContent').textContent;
            
            // Try to use the modern clipboard API
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(postContent).then(() => {
                    showNotification('Text copied successfully!', 'success');
                }).catch(() => {
                    // Fallback to older method
                    fallbackCopyText(postContent);
                });
            } else {
                // Fallback for older browsers
                fallbackCopyText(postContent);
            }
        }

        // Fallback copy method for older browsers
        function fallbackCopyText(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-9999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                document.execCommand('copy');
                showNotification('Text copied successfully!', 'success');
            } catch (err) {
                showNotification('Failed to copy text', 'error');
            }
            
            document.body.removeChild(textArea);
        }

        // Open LinkedIn
        function openLinkedIn() {
            window.open('https://www.linkedin.com/', '_blank');
            showNotification('LinkedIn opened', 'success');
        }

        // Close LinkedIn Modal
        function closeLinkedInModal() {
            const modal = document.getElementById('linkedinModal');
            if (modal) {
                modal.remove();
            }
        }

        // Initialize the application
        function init() {
            // Add initial day
            addDay();
            const firstDayButton = document.querySelector('button[onclick*="addSession"]');
            if (firstDayButton) {
                addSession(firstDayButton);
            }
            
            // Update day headers in case dates are pre-filled
            updateAllDayHeaders();
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>